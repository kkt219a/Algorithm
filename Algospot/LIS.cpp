// ALGOSPOT - LIS - 완전탐색 알고리즘 
int lis(const vector<int>& A){
	if(A.empty()) // 비었으면 더 볼게 없다는것
		return 0;
	int ret=0; 
	for(int i=0;i<A.size();i++){
		vector<int> B;
		for(int j=i+1;j<A.size();j++)
			if(A[i]<A[j]) // A[i] 보다 큰 녀석들만으로 이루어진 새로운 배열을 만들고
				B.push_back(A(j));
		ret=max(ret,1+lis(B)); // 뭐가더 큰지 비교후 그게 ret가 된다.
	} // 결국 n+(n-1)+(n-2)+ ... +2 +1 이 되는거다. 거기다 새로 만들어질 B배열들의 연산을 더하면 결국 어마어마 해짐 
	return ret;
}
// 메인문에선 lis(a) 이런식으로 넣어서 출력하면됨 a는 대신 벡터로
*/

/*
// ALGOSPOT - LIS -  dp알고리즘 (1)  O(N^2)의 시간복잡도
int n,dp[100],S[100];
// O(N^2);
//lis(start)=S[start]에서 시작하는 부분 증가 수열 중 최대의 길이
int lis2(int start){
	int &ret = dp[start];
	if(ret!=-1)
		return ret;
	ret=1; // 최소 아무것도 없어도 1이니까
	for(int next=start+1;next<n;next++){ // 다음것들과 계속 비교하면서 큰값 발견시 큰녀석의 우측을 다시 비교
		if(S[next]>S[start])
			ret=max(ret,lis2(next)+1); // 1더하는건 결과값에서 본인을 포함해서 계산 되어야 하니까.
	}
	return ret; // 최대 길이 반환
}
// 메인문에서 lis2(0)을 출력시켜주면됨.
*/

/*
// ALGOSPOT - LIS -  dp알고리즘 (2)  O(N^2)의 시간복잡도
int t,n,v[500]; 
int dp[501];
int lis3(int a){ // -1로 넣어주면 다 돌릴수있다.
	int &ret=dp[a+1];  // -1 들어올걸 대비해서.
	if(ret!=-1)
		return ret;
	ret=1; // 무조건 길이가 1은되니까.
	for(int i=a+1;i<n;i++) // 10 70 20 30 40 50 이라도 70들렸다가 20,30도 비교 해나가기 때문에 넘어설일 x 
		if(v[a]<v[i]||a==-1)
			ret=max(ret,LIS(i)+1); // a가 -1이면 0 부터 시작! 증가하다보면 최대값이 등장한다. 
	return ret; // 나중에 main문에서 부를때는 -1을해줘야한다. -1부터불러서 값이 1증가 해있기때문에.
}
// 메인문에서 lis3(-1)-1 을 넣어주면됨

*/

/*
// ALGOSPOT - LIS - dp알고리즘 (3), O(NlogN)의 시간복잡도를 가짐. 이분탐색을 이용한방법 . vector랑 세그먼트트리 해결법도 보기 
int t,n,v[500],ma; // ma는 최대 길이 반환 위해서
int dp[501];
void LIS(int a){
	if(ma==0||(ma>0&&dp[ma-1]<=a)){ // 최대길이0이거나, 0보다크고 이전값이 현재 들어온 숫자보다 작거나 같으면 
		dp[ma++]=a; //ma증가 시켜주면서 그값을 넣어준다.
		return;
	}
	//만약 작다면 
	int b=0,c=ma-1;
	while(b<=c){ // 들어갈 위치를 찾아준다. 
		int mid=(b+c)/2;
		if(dp[mid]<a)
			b=mid+1;
		else // b<=c가 성립되기 전에도 이경우로 돌아오면 c는 1감소한다, 
			c=mid-1;
	}
	dp[c+1]=a; // 자리를 찾아주는데 대신에 그냥 숫자가 들어가서 순증가 하는 거처럼 보여주기식. 실제 ma는 변화가 없으니까.
	// 10 20 40(1700) 25 20 50 30 70 85 일경우 10 20 1700 가다가 20대신 25가 들어가니 최대수에 영향없고(전자) 10 20 40 경우 25가 40자리에 들어간다(후자)
	//최대 길이를 구해야하니 마지막은 최대한 작을수록 긴 값을 구할수 있다. 그래서 계속 자리를 잡아주며 찾아주는거
	//근데 이 탐색 과정에서 DP에들어가는 원소는 LIS와 무관하다. 전자라면 중간에 무의미한 값들이 단지 증가순으로 들어갈수도 있기 때문이다.
	//단지 후자처럼 마지막수가 바뀔경우를 대비해서 이 이분탐색을 사용하는것. 근데 이게 앞에것과 문제없이하기위해 ma증가없는 수 집어넣기를 이루는것
}
// 메인문에서 v[]의 모든원소를 for문을 통해넣어주고, 출력할때 ma를 출력하면됨, 테스트케이스 for문에서 ma=0으로 항상 초기화 시켜줘야함.

*/

/*

//메인문까지 완성, LIS - 이진탐색을 이용한 O(NlogN)의 시간복잡도
#include<iostream>
#include<cstring>
using namespace std;
int t,n,v[500],ma; // ma는 최대 길이 반환 위해서
int dp[501];
void LIS(int a){
	if(ma==0||(ma>0&&dp[ma-1]<=a)){ // 최대길이0이거나, 0보다크고 이전값이 현재 들어온 숫자보다 작거나 같으면 
		dp[ma++]=a; //ma증가 시켜주면서 그값을 넣어준다.
		return;
	}
	//만약 작다면 
	int b=0,c=ma-1;
	while(b<=c){ // 들어갈 위치를 찾아준다. 
		int mid=(b+c)/2;
		if(dp[mid]<a)
			b=mid+1;
		else // b<=c가 성립되기 전에도 이경우로 돌아오면 c는 1감소한다, 
			c=mid-1;
	}
	dp[c+1]=a; // 자리를 찾아주는데 대신에 그냥 숫자가 들어가서 순증가 하는 거처럼 보여주기식. 실제 ma는 변화가 없으니까.
	// 10 20 40(1700) 25 20 50 30 70 85 일경우 10 20 1700 가다가 20대신 25가 들어가니 최대수에 영향없고(전자) 10 20 40 경우 25가 40자리에 들어간다(후자)
	//최대 길이를 구해야하니 마지막은 최대한 작을수록 긴 값을 구할수 있다. 그래서 계속 자리를 잡아주며 찾아주는거
	//근데 이 탐색 과정에서 DP에들어가는 원소는 LIS와 무관하다. 전자라면 중간에 무의미한 값들이 단지 증가순으로 들어갈수도 있기 때문이다.
	//단지 후자처럼 마지막수가 바뀔경우를 대비해서 이 이분탐색을 사용하는것. 근데 이게 앞에것과 문제없이하기위해 ma증가없는 수 집어넣기를 이루는것
}

int main(){
	cin>>t;
	for(int i=0;i<t;i++){
		ma=0;
		memset(v,-1,sizeof(v));
		memset(dp,-1,sizeof(dp));
		cin>>n;
		for(int j=0;j<n;j++)
			cin>>v[j];
		for(int j=0;j<n;j++)
			LIS(v[j]);
		cout<<ma;
		
	}
}
// 10 20 40 25 20 50 30 70 85 >> 10 20 25 30 70 85
