//백준 - 15685 - 드래곤 커브
//재밌당, 기회되면 다시
#include<iostream>
#include<cstring>
int a[4]={1,0,-1,0},b[4]={0,-1,0,1};
//a와 b각각 x좌표 , y좌표 각 번호에대해서 움직임.
int n,x[20],y[20],d[20],g[20];
//드래곤커브 수, 시작점들,  시작방향, 드래곤커브 수
int c[101][101];
//for문 돌기위한 , 좌표점들 방문 여부 
int k[1025],l,j,t,p,i;
//k는 경로 저장용, 어떻게 이어 들어 갈건지. l,j,t,p,i는 구하는 도중 반복문에 쓰이는 변수들.
int h;
//정답
int main(){
	std::cin>>n;
	for(;i<n;i++){
		t=0;// 제일 하단에서 t를 사용했으니까 초기화 해준다.
		memset(k,-1,sizeof(k)); //k안에 0이 들어가기에, 없는걸 구분위해 -1로 해둬야함.
		std::cin>>x[i]>>y[i]>>d[i]>>g[i];
		k[1]=d[i]; // 0세대를 저장해둔다. 1개니까.
		for(l=1,j=2;l<=g[i];l++,j*=2) //l은 세대. 0세대면 통과, 1세대부터 2개이니까 j와 같이 돌려준다. 세대 만큼.
			for(t=j,p=1;t>j/2;t--,p++){ // 서로 양 끝을 바라보게하고 어차피 짝수니까 중간에서 두개가 만날때까지.
				k[t]=k[p]+1; // (0,j) (1,j-1) . . . (j/2-1,j/2+1) -->>이런식으로! j/2-1부터 0까지 1을더해서 j/2+1부터 j까지 두면 그게 경로다. 
				if(k[t]>3) // 4라는건 3다음 0 이되야하는데 4가 됬다는거. 0으로 되돌려주기.
					k[t]=0;
			}
		
		c[x[i]][y[i]]=1;// 첫번째 점은 먼저 넣어주고.
		for(t=1;t<=j/2;t++){// 점들을 찍어주는 작업.
			x[i]+=a[k[t]]; // 각 경로들마다 들어가면서, 증가시켜주며 방문을 찍는다.
			y[i]+=b[k[t]];
			c[x[i]][y[i]]=1; 
		}
		
	}
	
	for(t=0;t<100;t++)
		for(p=0;p<100;p++){
			if(c[t][p]&&c[t+1][p+1]&&c[t+1][p]&&c[t][p+1]) // 그 점 주변으로 사각형이 방문 되었는지 안 되었는지.
				h++;
		}
	
	std::cout<<h;
}